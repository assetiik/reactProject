"use strict";
//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const OffsetStorage_1 = require("./OffsetStorage");
const TokenInfo_1 = require("./TokenInfo");
const util_1 = require("../../util");
const GLOBAL_LINEBREAK_REGEX = /\r\n|[\r\n\u2028\u2029]/gu;
const WHITESPACE_REGEX = /\s*$/u;
//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
const KNOWN_NODES = new Set([
    utils_1.AST_NODE_TYPES.AssignmentExpression,
    utils_1.AST_NODE_TYPES.AssignmentPattern,
    utils_1.AST_NODE_TYPES.ArrayExpression,
    utils_1.AST_NODE_TYPES.ArrayPattern,
    utils_1.AST_NODE_TYPES.ArrowFunctionExpression,
    utils_1.AST_NODE_TYPES.AwaitExpression,
    utils_1.AST_NODE_TYPES.BlockStatement,
    utils_1.AST_NODE_TYPES.BinaryExpression,
    utils_1.AST_NODE_TYPES.BreakStatement,
    utils_1.AST_NODE_TYPES.CallExpression,
    utils_1.AST_NODE_TYPES.CatchClause,
    utils_1.AST_NODE_TYPES.ClassBody,
    utils_1.AST_NODE_TYPES.ClassDeclaration,
    utils_1.AST_NODE_TYPES.ClassExpression,
    utils_1.AST_NODE_TYPES.ConditionalExpression,
    utils_1.AST_NODE_TYPES.ContinueStatement,
    utils_1.AST_NODE_TYPES.DoWhileStatement,
    utils_1.AST_NODE_TYPES.DebuggerStatement,
    utils_1.AST_NODE_TYPES.EmptyStatement,
    utils_1.AST_NODE_TYPES.ExpressionStatement,
    utils_1.AST_NODE_TYPES.ForStatement,
    utils_1.AST_NODE_TYPES.ForInStatement,
    utils_1.AST_NODE_TYPES.ForOfStatement,
    utils_1.AST_NODE_TYPES.FunctionDeclaration,
    utils_1.AST_NODE_TYPES.FunctionExpression,
    utils_1.AST_NODE_TYPES.Identifier,
    utils_1.AST_NODE_TYPES.IfStatement,
    utils_1.AST_NODE_TYPES.Literal,
    utils_1.AST_NODE_TYPES.LabeledStatement,
    utils_1.AST_NODE_TYPES.LogicalExpression,
    utils_1.AST_NODE_TYPES.MemberExpression,
    utils_1.AST_NODE_TYPES.MetaProperty,
    utils_1.AST_NODE_TYPES.MethodDefinition,
    utils_1.AST_NODE_TYPES.NewExpression,
    utils_1.AST_NODE_TYPES.ObjectExpression,
    utils_1.AST_NODE_TYPES.ObjectPattern,
    utils_1.AST_NODE_TYPES.Program,
    utils_1.AST_NODE_TYPES.Property,
    utils_1.AST_NODE_TYPES.RestElement,
    utils_1.AST_NODE_TYPES.ReturnStatement,
    utils_1.AST_NODE_TYPES.SequenceExpression,
    utils_1.AST_NODE_TYPES.SpreadElement,
    utils_1.AST_NODE_TYPES.Super,
    utils_1.AST_NODE_TYPES.SwitchCase,
    utils_1.AST_NODE_TYPES.SwitchStatement,
    utils_1.AST_NODE_TYPES.TaggedTemplateExpression,
    utils_1.AST_NODE_TYPES.TemplateElement,
    utils_1.AST_NODE_TYPES.TemplateLiteral,
    utils_1.AST_NODE_TYPES.ThisExpression,
    utils_1.AST_NODE_TYPES.ThrowStatement,
    utils_1.AST_NODE_TYPES.TryStatement,
    utils_1.AST_NODE_TYPES.UnaryExpression,
    utils_1.AST_NODE_TYPES.UpdateExpression,
    utils_1.AST_NODE_TYPES.VariableDeclaration,
    utils_1.AST_NODE_TYPES.VariableDeclarator,
    utils_1.AST_NODE_TYPES.WhileStatement,
    utils_1.AST_NODE_TYPES.WithStatement,
    utils_1.AST_NODE_TYPES.YieldExpression,
    utils_1.AST_NODE_TYPES.JSXIdentifier,
    utils_1.AST_NODE_TYPES.JSXMemberExpression,
    utils_1.AST_NODE_TYPES.JSXEmptyExpression,
    utils_1.AST_NODE_TYPES.JSXExpressionContainer,
    utils_1.AST_NODE_TYPES.JSXElement,
    utils_1.AST_NODE_TYPES.JSXClosingElement,
    utils_1.AST_NODE_TYPES.JSXOpeningElement,
    utils_1.AST_NODE_TYPES.JSXAttribute,
    utils_1.AST_NODE_TYPES.JSXSpreadAttribute,
    utils_1.AST_NODE_TYPES.JSXText,
    utils_1.AST_NODE_TYPES.ExportDefaultDeclaration,
    utils_1.AST_NODE_TYPES.ExportNamedDeclaration,
    utils_1.AST_NODE_TYPES.ExportAllDeclaration,
    utils_1.AST_NODE_TYPES.ExportSpecifier,
    utils_1.AST_NODE_TYPES.ImportDeclaration,
    utils_1.AST_NODE_TYPES.ImportSpecifier,
    utils_1.AST_NODE_TYPES.ImportDefaultSpecifier,
    utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier,
    // Class properties aren't yet supported by eslint...
    utils_1.AST_NODE_TYPES.PropertyDefinition,
    // ts keywords
    utils_1.AST_NODE_TYPES.TSAbstractKeyword,
    utils_1.AST_NODE_TYPES.TSAnyKeyword,
    utils_1.AST_NODE_TYPES.TSBooleanKeyword,
    utils_1.AST_NODE_TYPES.TSNeverKeyword,
    utils_1.AST_NODE_TYPES.TSNumberKeyword,
    utils_1.AST_NODE_TYPES.TSStringKeyword,
    utils_1.AST_NODE_TYPES.TSSymbolKeyword,
    utils_1.AST_NODE_TYPES.TSUndefinedKeyword,
    utils_1.AST_NODE_TYPES.TSUnknownKeyword,
    utils_1.AST_NODE_TYPES.TSVoidKeyword,
    utils_1.AST_NODE_TYPES.TSNullKeyword,
    // ts specific nodes we want to support
    utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition,
    utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition,
    utils_1.AST_NODE_TYPES.TSArrayType,
    utils_1.AST_NODE_TYPES.TSAsExpression,
    utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration,
    utils_1.AST_NODE_TYPES.TSConditionalType,
    utils_1.AST_NODE_TYPES.TSConstructorType,
    utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration,
    utils_1.AST_NODE_TYPES.TSDeclareFunction,
    utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression,
    utils_1.AST_NODE_TYPES.TSEnumDeclaration,
    utils_1.AST_NODE_TYPES.TSEnumMember,
    utils_1.AST_NODE_TYPES.TSExportAssignment,
    utils_1.AST_NODE_TYPES.TSExternalModuleReference,
    utils_1.AST_NODE_TYPES.TSFunctionType,
    utils_1.AST_NODE_TYPES.TSImportType,
    utils_1.AST_NODE_TYPES.TSIndexedAccessType,
    utils_1.AST_NODE_TYPES.TSIndexSignature,
    utils_1.AST_NODE_TYPES.TSInferType,
    utils_1.AST_NODE_TYPES.TSInterfaceBody,
    utils_1.AST_NODE_TYPES.TSInterfaceDeclaration,
    utils_1.AST_NODE_TYPES.TSInterfaceHeritage,
    utils_1.AST_NODE_TYPES.TSIntersectionType,
    utils_1.AST_NODE_TYPES.TSImportEqualsDeclaration,
    utils_1.AST_NODE_TYPES.TSLiteralType,
    utils_1.AST_NODE_TYPES.TSMappedType,
    utils_1.AST_NODE_TYPES.TSMethodSignature,
    'TSMinusToken',
    utils_1.AST_NODE_TYPES.TSModuleBlock,
    utils_1.AST_NODE_TYPES.TSModuleDeclaration,
    utils_1.AST_NODE_TYPES.TSNonNullExpression,
    utils_1.AST_NODE_TYPES.TSParameterProperty,
    'TSPlusToken',
    utils_1.AST_NODE_TYPES.TSPropertySignature,
    utils_1.AST_NODE_TYPES.TSQualifiedName,
    'TSQuestionToken',
    utils_1.AST_NODE_TYPES.TSRestType,
    utils_1.AST_NODE_TYPES.TSThisType,
    utils_1.AST_NODE_TYPES.TSTupleType,
    utils_1.AST_NODE_TYPES.TSTypeAnnotation,
    utils_1.AST_NODE_TYPES.TSTypeLiteral,
    utils_1.AST_NODE_TYPES.TSTypeOperator,
    utils_1.AST_NODE_TYPES.TSTypeParameter,
    utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration,
    utils_1.AST_NODE_TYPES.TSTypeParameterInstantiation,
    utils_1.AST_NODE_TYPES.TSTypeReference,
    utils_1.AST_NODE_TYPES.TSUnionType,
]);
const STATEMENT_LIST_PARENTS = new Set([
    utils_1.AST_NODE_TYPES.Program,
    utils_1.AST_NODE_TYPES.BlockStatement,
    utils_1.AST_NODE_TYPES.SwitchCase,
]);
const DEFAULT_VARIABLE_INDENT = 1;
const DEFAULT_PARAMETER_INDENT = 1;
const DEFAULT_FUNCTION_BODY_INDENT = 1;
/*
 * General rule strategy:
 * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another
 *    specified token or to the first column.
 * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a
 *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly
 *    brace of the BlockStatement.
 * 3. After traversing the AST, calculate the expected indentation levels of every token according to the
 *    OffsetStorage container.
 * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,
 *    and report the token if the two values are not equal.
 */
const ELEMENT_LIST_SCHEMA = {
    oneOf: [
        {
            type: 'integer',
            minimum: 0,
        },
        {
            enum: ['first', 'off'],
        },
    ],
};
exports.default = (0, util_1.createRule)({
    name: 'indent',
    meta: {
        type: 'layout',
        docs: {
            description: 'Enforce consistent indentation.',
            recommended: false,
        },
        fixable: 'whitespace',
        schema: [
            {
                oneOf: [
                    {
                        enum: ['tab'],
                    },
                    {
                        type: 'integer',
                        minimum: 0,
                    },
                ],
            },
            {
                type: 'object',
                properties: {
                    SwitchCase: {
                        type: 'integer',
                        minimum: 0,
                        default: 0,
                    },
                    VariableDeclarator: {
                        oneOf: [
                            ELEMENT_LIST_SCHEMA,
                            {
                                type: 'object',
                                properties: {
                                    var: ELEMENT_LIST_SCHEMA,
                                    let: ELEMENT_LIST_SCHEMA,
                                    const: ELEMENT_LIST_SCHEMA,
                                },
                                additionalProperties: false,
                            },
                        